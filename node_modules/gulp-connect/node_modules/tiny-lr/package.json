{
  "author": {
    "name": "mklabs"
  },
  "name": "tiny-lr",
  "description": "Tiny LiveReload server, background-friendly",
  "version": "0.0.7",
  "homepage": "https://github.com/mklabs/tiny-lr",
  "repository": {
    "url": "git://github.com/mklabs/tiny-lr.git"
  },
  "bin": {
    "tiny-lr": "./bin/tiny-lr"
  },
  "main": "./lib",
  "scripts": {
    "prepublish:": "npm test",
    "test": "mocha --reporter list",
    "test-debug": "DEBUG=tinylr:* mocha --reporter list",
    "test-debug-all": "DEBUG=* mocha --reporter list"
  },
  "dependencies": {
    "qs": "~0.5.2",
    "faye-websocket": "~0.4.3",
    "noptify": "~0.0.3",
    "debug": "~0.8.0"
  },
  "devDependencies": {
    "mocha": "~1.7.1",
    "request": "~2.12.0",
    "supertest": "~0.4.2",
    "express": "~3.0.6",
    "connect": "~2.7.2"
  },
  "config": {
    "test_port": "9001"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "https://github.com/mklabs/tiny-lr/blob/master/LICENSE-MIT"
    }
  ],
  "readme": "tiny-lr\r\n-------\r\n\r\nThis script manages a tiny [LiveReload](http://livereload.com/) server\r\nimplementation.\r\n\r\n[![Build Status](https://travis-ci.org/mklabs/tiny-lr.svg?branch=master)](https://travis-ci.org/mklabs/tiny-lr)\r\n[![NPM](https://nodei.co/npm/tiny-lr.png?compact=true)](https://nodei.co/npm/tiny-lr/)\r\n\r\nIt exposes an HTTP server and express middleware, with a very basic REST\r\nApi to notify the server of a particular change.\r\n\r\nIt doesn't have any watch ability, it must be done at the build process or\r\napplication level.\r\n\r\nInstead, it exposes a very simple API to notify the server that some\r\nchanges have been made, then broadcasted to every livereload client\r\nconnected.\r\n\r\n    # notify a single change\r\n    curl http://localhost:35729/changed?files=style.css\r\n\r\n    # notify using a longer path\r\n    curl http://localhost:35729/changed?files=js/app.js\r\n\r\n    # notify multiple changes, comma or space delimited\r\n    curl http://localhost:35729/changed?files=index.html,style.css,docs/docco.css\r\n\r\nOr you can bulk the information into a POST request, with body as a JSON array of files.\r\n\r\n    curl -X POST http://localhost:35729/changed -d '{ \"files\": [\"style.css\", \"app.js\"] }'\r\n\r\nAs for the livereload client, you need to install the browser extension:\r\nhttp://feedback.livereload.com/knowledgebase/articles/86242-how-do-i-install-and-use-the-browser-extensions-\r\n(**note**: you need to listen on port 35729 to be able to use with your\r\nbrower extension)\r\n\r\nor add the livereload script tag manually:\r\nhttp://feedback.livereload.com/knowledgebase/articles/86180-how-do-i-add-the-script-tag-manually-\r\n(and here you can choose whatever port you want)\r\n\r\n## Integration\r\n\r\nThis package exposes a `bin` you can decide to install globally, but it's not recommended.\r\n\r\n    tiny-lr --help\r\n\r\n    Usage: tiny-lr [options]\r\n\r\n    Options:\r\n      -h, --help        - Show help usage\r\n      -v, --version     - Show package version\r\n      -p, --port        - Port to listen on (default: 35729)\r\n      --pid             - Path to the generated PID file (default: ./tiny-lr.pid)\r\n\r\n\r\nThe best way to integrate the runner in your workflow is to add it as a `reload`\r\nstep within your build tool. This build tool can then use the internal binary\r\nlinked by npm in `node_modules/.bin/tiny-lr` to not rely on global installs (or\r\nuse the server programmtically).\r\n\r\nYou can start the server using the binary provided, or use your own start script.\r\n\r\n```js\r\nvar tinylr = require('tiny-lr');\r\n\r\n// standard LiveReload port\r\nvar port = 35729;\r\n\r\n// tinylr(opts) => new tinylr.Server(opts);\r\ntinylr().listen(port, function() {\r\n  if(err) {\r\n    // deal with err\r\n    return;\r\n  }\r\n\r\n  console.log('... Listening on %s (pid: %s) ...', port);\r\n})\r\n```\r\n\r\nYou can define your own route and listen for specific request:\r\n\r\n```js\r\nvar server = tinylr();\r\n\r\nserver.on('GET /myplace', function(req, res) {\r\n  res.write('Mine');\r\n  res.end();\r\n})\r\n```\r\n\r\nAnd stop the server manually:\r\n\r\n```js\r\nserver.close();\r\n```\r\n\r\nThis will close any websocket connection established and emit a close event.\r\n\r\n### Middleware\r\n\r\nTo use as a connect / express middleware, tiny-lr needs query /\r\nbodyParse middlewares prior in the stack.\r\n\r\nAny handled requests ends at the tinylr level, not found and errors are\r\nnexted to the rest of the stack.\r\n\r\n```js\r\n// This binds both express app and tinylr on the same port\r\nvar app = express();\r\napp.use(express.query())\r\n  .use(express.bodyParser())\r\n  .use(tinylr.middleware({ app: app }))\r\n  .use(express.static(path.resolve('./')))\r\n  .use(express.directory(path.resolve('./')))\r\n  .listen(35729, function() {\r\n    console.log('Listening on %d', 35729);\r\n  })\r\n```\r\n\r\nThe port you listen on is important, and tinylr should **always** listen on\r\nthe LiveReload standard one: `35729`. Otherwise, you won't be able to rely\r\non the browser extensions, though you can still use the manual snippet\r\napproach.\r\n\r\nYou can also start two different servers, one on your app port, the\r\nother listening on the LiveReload port. Check the\r\n`examples/express/server.js` file to see how.\r\n\r\n### Using grunt\r\n\r\nHead over to [https://github.com/gruntjs/grunt-contrib-watch](https://github.com/gruntjs/grunt-contrib-watch#live-reloading)\r\n\r\n### Using make\r\n\r\nSee [`tinylr.mk`](./tinylr.mk) file.\r\n\r\nInclude this file into your project Makefile to bring in the following targets:\r\n\r\n- start \t\t\t\t\t\t- Start the LiveReload server\r\n- stop \t\t\t\t\t\t\t- Stops the LiveReload server\r\n- livereload \t\t\t\t- alias to start\r\n- livereload-stop \t- aias to stop\r\n\r\nThen define your \"empty\" targets, and the list of files you want to monitor.\r\n\r\n```make\r\nCSS_DIR = app/styles\r\nCSS_FILES = $(shell find $(CSS_DIR) -name '*.css')\r\n\r\n# include the livereload targets\r\ninclude node_modules/tiny-lr/tinylr.mk\r\n\r\n$(CSS_DIR): $(CSS_FILES)\r\n  @echo CSS files changed: $?\r\n  @touch $@\r\n  curl -X POST http://localhost:35729/changed -d '{ \"files\": \"$?\" }'\r\n\r\nreload-css: livereload $(CSS_DIR)\r\n\r\n.PHONY: reload-css\r\n```\r\n\r\nThe pattern is always the same:\r\n\r\n- define a target for your root directory that triggers a POST request\r\n- `touch` the directory to update its mtime\r\n- add reload target with `livereload` and the list of files to \"watch\" as prerequisites\r\n\r\nYou can chain multiple \"reload\" targets in a single one:\r\n\r\n```make\r\nreload: reload-js reload-css reload-img reload-EVERYTHING\r\n```\r\n\r\nCombine this with [visionmedia/watch](https://github.com/visionmedia/watch) and\r\nyou have a livereload environment.\r\n\r\n    watch make reload\r\n\r\n    # add a -q flag to the watch command to suppress most of the annoying output\r\n    watch -q reload\r\n\r\nThe `-q` flag only outputs STDERR, you can in your Makefile redirect the\r\noutput of your commands to `>&2` to see them in `watch -q` mode.\r\n\r\n## Tests\r\n\r\n    npm test\r\n\r\n---\r\n\r\n\r\n# TOC\r\n   - [tiny-lr](#tiny-lr)\r\n     - [GET /](#tiny-lr-get-)\r\n     - [GET /changed](#tiny-lr-get-changed)\r\n     - [POST /changed](#tiny-lr-post-changed)\r\n     - [GET /livereload.js](#tiny-lr-get-livereloadjs)\r\n     - [GET /kill](#tiny-lr-get-kill)\r\n<a name=\"\" />\r\n\r\n<a name=\"tiny-lr\" />\r\n# tiny-lr\r\naccepts ws clients.\r\n\r\n```js\r\nvar url = parse(this.request.url);\r\nvar server = this.app;\r\n\r\nvar ws = this.ws = new WebSocket('ws://' + url.host + '/livereload');\r\n\r\nws.onopen = function(event) {\r\n  var hello = {\r\n    command: 'hello',\r\n    protocols: ['http://livereload.com/protocols/official-7']\r\n  };\r\n\r\n  ws.send(JSON.stringify(hello));\r\n};\r\n\r\nws.onmessage = function(event) {\r\n  assert.deepEqual(event.data, JSON.stringify({\r\n    command: 'hello',\r\n    protocols: ['http://livereload.com/protocols/official-7'],\r\n    serverName: 'tiny-lr'\r\n  }));\r\n\r\n  assert.ok(Object.keys(server.clients).length);\r\n  done();\r\n};\r\n```\r\n\r\nproperly cleans up established connection on exit.\r\n\r\n```js\r\nvar ws = this.ws;\r\n\r\nws.onclose = done.bind(null, null);\r\n\r\nrequest(this.server)\r\n  .get('/kill')\r\n  .expect(200, function() {\r\n    console.log('server shutdown');\r\n  });\r\n```\r\n\r\n<a name=\"tiny-lr\" />\r\n# tiny-lr\r\n<a name=\"tiny-lr-get-\" />\r\n## GET /\r\nrespond with nothing, but respond.\r\n\r\n```js\r\nrequest(this.server)\r\n  .get('/')\r\n  .expect('Content-Type', /json/)\r\n  .expect('{\"tinylr\":\"Welcome\",\"version\":\"0.0.1\"}')\r\n  .expect(200, done);\r\n```\r\n\r\nunknown route respond with proper 404 and error message.\r\n\r\n```js\r\nrequest(this.server)\r\n  .get('/whatev')\r\n  .expect('Content-Type', /json/)\r\n  .expect('{\"error\":\"not_found\",\"reason\":\"no such route\"}')\r\n  .expect(404, done);\r\n```\r\n\r\n<a name=\"tiny-lr-get-changed\" />\r\n## GET /changed\r\nwith no clients, no files.\r\n\r\n```js\r\nrequest(this.server)\r\n  .get('/changed')\r\n  .expect('Content-Type', /json/)\r\n  .expect(/\"clients\":\\[\\]/)\r\n  .expect(/\"files\":\\[\\]/)\r\n  .expect(200, done);\r\n```\r\n\r\nwith no clients, some files.\r\n\r\n```js\r\nrequest(this.server)\r\n  .get('/changed?files=gonna.css,test.css,it.css')\r\n  .expect('Content-Type', /json/)\r\n  .expect('{\"clients\":[],\"files\":[\"gonna.css\",\"test.css\",\"it.css\"]}')\r\n  .expect(200, done);\r\n```\r\n\r\n<a name=\"tiny-lr-post-changed\" />\r\n## POST /changed\r\nwith no clients, no files.\r\n\r\n```js\r\nrequest(this.server)\r\n  .post('/changed')\r\n  .expect('Content-Type', /json/)\r\n  .expect(/\"clients\":\\[\\]/)\r\n  .expect(/\"files\":\\[\\]/)\r\n  .expect(200, done);\r\n```\r\n\r\nwith no clients, some files.\r\n\r\n```js\r\nvar data = { clients: [], files: ['cat.css', 'sed.css', 'ack.js'] };\r\n\r\nrequest(this.server)\r\n  .post('/changed')\r\n  .send({ files: data.files })\r\n  .expect('Content-Type', /json/)\r\n  .expect(JSON.stringify(data))\r\n  .expect(200, done);\r\n```\r\n\r\n<a name=\"tiny-lr-get-livereloadjs\" />\r\n## GET /livereload.js\r\nrespond with livereload script.\r\n\r\n```js\r\nrequest(this.server)\r\n  .get('/livereload.js')\r\n  .expect(/LiveReload/)\r\n  .expect(200, done);\r\n```\r\n\r\n<a name=\"tiny-lr-get-kill\" />\r\n## GET /kill\r\nshutdown the server.\r\n\r\n```js\r\nvar server = this.server;\r\nrequest(server)\r\n  .get('/kill')\r\n  .expect(200, function(err) {\r\n    if(err) return done(err);\r\n    assert.ok(!server._handle);\r\n    done();\r\n  });\r\n```\r\n\r\n## Thanks!\r\n\r\n- Tiny-lr is a [LiveReload](http://livereload.com/) implementation. They\r\n  really made frontend editing better for a lot of us. They have a\r\n  [LiveReload App on the Mac App Store](https://itunes.apple.com/us/app/livereload/id482898991)\r\n  you might want to check out.\r\n\r\n- To all [contributors](https://github.com/mklabs/tiny-lr/graphs/contributors)\r\n\r\n- [@FGRibreau](https://github.com/FGRibreau) / [pid.js gist](https://gist.github.com/1846952)) for the background friendly bin wrapper\r\n\r\n---\r\n\r\n- 2014-05-01 - v0.0.6 - #41 - Sync with lastest changes from tiny-lr fork / Cleanup code from tasks / examples. See https://github.com/gruntjs/grunt-contrib-watch for grunt integration.\r\n- 2013-01-21 - v0.0.5 - [PR #18](https://github.com/mklabs/tiny-lr/pull/18) / [PR #21](https://github.com/mklabs/tiny-lr/pull/21) - https support / expose reload flags through options\r\n- 2013-01-21 - v0.0.4 - middleware support\r\n- 2013-01-20 - v0.0.3 - serve livereload from repo (#4)\r\n- 2013-01-12 - v0.0.2 - tasks - support for grunt 0.3.x (#1)\r\n- 2013-01-05 - v0.0.1 - Initial release\r\n",
  "readmeFilename": "readme.md",
  "bugs": {
    "url": "https://github.com/mklabs/tiny-lr/issues"
  },
  "_id": "tiny-lr@0.0.7",
  "_from": "tiny-lr@>=0.0.7 <0.0.8"
}
